---
layout: post
title: rails project
---

"Stravinsky says the composer should practice his trade exactly as a shoemaker does. Mozart and Haydn accepted commissions--wrote to order. In the nineteenth century, the artist loftily waited for inspiration. Once you elevate yourself to the rank of a cultural institution, you're in for a lot of trouble."

  -Saul Bellow, from the Paris Review's 'Art of Fiction'


======
**the project**
======

**requirements** >> build a Ruby on Rails application that manages related data through complex forms and RESTful routes.

**what** >> a communal storytelling app called Storyline. the idea is simple: anyone can start a story, and anyone can add the next sentence to someone else’s story. the only restriction is that users can’t post two times in a row to the same story. users can upvote stories and sentences that they like, and user stats pages keep track of how many upvotes a user has.


**where** >> [github](https://github.com/bennorris/storyline)

**why** >> writers have to exercise an obsessive level of control over the language, structure, and development of their stories. i thought it would be interesting to undo that control and see a story unravel based on varying voices and ideas.

======
**the takeaway**
======

Sinatra is wonderfully explicit. Because of that, Sinatra gives the feeling of having total control over what’s happening — at the expense of it being very manual. Making the transition to Rails involved accepting a certain amount of magic, which felt frustratng at the beginning. Where were the views for these Devise login pages? And wasn’t this relationship between the route, an empty method in the controller, and the view a bit circuitous?

But after digging behind the magic for a few days, Rails went from frustrating to exciting. And many of the time-consuming processes in Sinatra — like defining individual routes in the controller — became so much quicker.

**storyline snapshots**

login:
<img src="https://bennorris.github.io/blog/assets/storyline-login.png" width="200" height="200" />

![login](https://bennorris.github.io/blog/assets/storyline-login.png){: .center-image }

homepage:

![homepage](https://bennorris.github.io/blog/assets/storyline-homepage1.png){: .center-image }
![homepage](https://bennorris.github.io/blog/assets/storyline-homepage2.png){: .center-image }


user stats:
![user stats](https://bennorris.github.io/blog/assets/storyline-stats.png){: .center-image }

individual story page
![story page](https://bennorris.github.io/blog/assets/storyline-story1.png){: .center-image }

![story page](https://bennorris.github.io/blog/assets/storyline-story1.png){: .center-image }

individual sentence page
![sentence page](https://bennorris.github.io/blog/assets/storyline-sentence1.png){: .center-image }



======
**lessons learned**
======

-to associate one model to another with both belongs_to and has_many through: relationships, you need to add a foreign key to the has_many through: \\
ex:

```ruby
class Story < ApplicationRecord
  belongs_to :user
  has_many :sentences
  has_many :users, through: :sentences, :foreign_key => "user_id"
```

-if you have a model that will belongs_to multiple other models but don't want a laundry list of foreign keys, you can use a polymorphic association. For example - for an Upvotes model that may be applicable to photos, posts, etc., you can name the foreign key with the name of the model+able_id (so in this case, upvotable_id), plus add an additional column for upvotable_type (which is a string). Then, in the has_many models, you associate the polymorphic association by adding :as => :upvotable. An example:

```ruby
class Sentence < ApplicationRecord
  belongs_to :story
  belongs_to :user
  has_many :upvotes, :as => :upvotable
  end

  class Upvote < ApplicationRecord
  belongs_to :upvotable, :polymorphic => true
  end

  class Story < ApplicationRecord
  belongs_to :user
  has_many :sentences
  has_many :upvotes, :as => :upvotable
  has_many :users, through: :sentences, :foreign_key => "user_id"
```
